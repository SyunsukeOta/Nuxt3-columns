## 開発サーバでの実行
- 場所: http://localhost:3000
- 今回は npm で実行

```sh
npm run dev
```

## ビルド
```sh
npm run build
```

## TODO
- 変数、関数名をそのまま移植していてわかりにくいのでブランチを切って再実装する。
- 開発手順のA~Jで実装する必要のあるものを全て列挙する
- 定数は game_constants.ts として一括管理
  - 後から pinia の store でstateとして静的データ(config)と動的データを一括で管理(app.config.ts)
  - 作成したconfigファイルはvueファイル内でuseAppConfig()を実行して呼び出せる

## コラムスの開発手順
![開発手順](assets/imgs/開発手順.png)

![移植前のコラムスのプレイ画面](assets/imgs/プレイ画面.png)


### A. 宝石の設定
1. 一回につき、1ブロック(3個の宝石が縦に連なっている)が落ちてくる
2. 宝石の色は赤、青、緑、黄、オレンジ、紫の6種類

- javascriptのcanvasとの同期
  - pixiContainer(template 内のdiv要素)の子要素としてcanvasを追加
  - pixi.jsのApplicationオブジェクトを初期化し、縦横幅、背景色などの設定
  - ステージの作成: pixi.jsのGrapichsオブジェクトを初期化し、縦横幅、背景色などの設定

- 宝石の色は色名とカラーコードの対応表(Mapで実装)
  - キーが色の英語名の文字列、バリューがカラーコード
  - keys()メソッドでキー一覧を取得可能

```
const colorMap: Map<string, number> = new Map();
map.set([
  ["red", 0xff0000],
  ["green", 0x00ff00],
  ["blue", 0x0000ff],
  ["yellow", 0xffff00],
  ["orange", 0xffa500],
  ["purple", 0x800080]
]);
const colorKeys = Array.from(colorMap.keys());
```

- 宝石の描画
  1. ランダムで色を指定
  2. 指定した色とサイズ(定数)で宝石を初期値に描画
  3. 描画した宝石を指定した座標に変更

- ブロックの描画処理
  1. ブロック配列の用意
  2. ブロックの座標を決定
  3. それに合わせて、各宝石の座標を計算
  4. 計算した座標を使用して各宝石を描画させる
  5. 宝石(Graphics型)をブロック配列に格納

- 宝石の型(JewelType)の用意
  - jewel(Grapics型): 宝石のpixijsで使用するオブジェクト
  - color(文字列): 宝石の色を示す
  - isDelete(真偽値): 削除予定かそうでないかのフラグ

### B. 宝石のスライド
3. 一回ボタンを押したら下方向に操作中のブロックがスライドする

- 移動中のブロックの位置の再計算を行う関数の作成
  - 対象のブロック内の各宝石に対して、x, y 座標を再計算する

- ブロックを下方向に回転させる関数の作成(rotateBlock)
  1. ブロックの配列内で配列操作によってブロック内の宝石の入れ替えを行う
  2. 各宝石のy座標を再計算して変更(ブロック座標の再計算関数を使用)

- 指定したブロックの情報をログに出力
  - ブロック内に要素がある場合に限り、ブロック内の各番地とその宝石の色名を出力

### C. ブロックの移動
4. 左右、下でブロックを操作

- 各移動に対応する関数の実装
  1. 移動中のブロックのx,yの場所を増減させて、各移動に対応
  2. 移動中のブロックの位置の再計算

- キーアクションの追加
  1. それぞれのキーと移動関数を対応付けする関数を作成
  2. 作成した関数をonMounted内でevent listenerに追加
  3. 作成した関数をonBeforeUnmount内でevent listenerから削除

### D. ブロックの停止条件
5. 下に移動できなければ(地面や宝石と接すれば)、操作中のブロックは止まる

- ボード内の宝石を描画する関数
  - ボード内の宝石の情報が入っている配列を使用して描画

- 移動先に設置済みの宝石があるかを確認
  1. ボード内の宝石の配列を確認
  2. 操作中の宝石のどの方向をチェックするかを取得して、それに合わせてチェック

- 移動先に壁があるかの確認
  1. 確認する壁の方向を取得
  2. 取得した方向に対して、ブロックの隣が壁かを確認

- 下に移動する関数に追記
  1. 停止条件を追記
  2. 操作中のブロックの内容をボードの宝石の配列に追記
  3. 操作中のブロックの場所を初期位置にする
  4. 操作中のブロック配列内のGraphicsオブジェクトを削除して初期化
  5. その後、もう一度新しい宝石を作成してそれぞれ操作中のブロック配列内に入れる

- ボード内の全ての宝石の色をlogに表示させる関数
  - ブロックが存在すれば色を表示させ、なければNone

### E. 宝石の削除機能(<-いまここ)
6. 同じ種類の宝石が縦、横、斜めに三個以上繋がれば消える
7. 6で消えた時に、浮いている宝石が下に落ちる
8. 落ちた後に、6を実行

- 宝石を削除するかの判断
  1. 確認する宝石を受け取る
  2. 縦・横・斜めx2の4つの評価軸で確認する宝石と隣り合う宝石の色が同じかを判断
  3. 2で同じと判断した場合は、宝石内のフラグ(deleteFlag)をTrueにする

- 削除手順
  1. 操作中のブロックが停止した時にブロック内の各宝石に対して宝石の削除判定を行う
  2. 先頭の宝石から順に確認
    2.1 フラグがTrueの箇所削除
    2.2 削除した宝石の数をカウント
    2.3 再描画
  3. 一列ずつ確認する
    3.1 一番下の空の宝石に対してそれより上の宝石を一つずつ下にずらす
    3.2 これを空の宝石がなくなるまで繰り返す
    3.3 最初に消した空の宝石の場所を保存しておく
  4. 各列に対して、3.3 で保存した場所よりも上の場所(横は同じ)に対して宝石の削除判定を行う
  5. 再描画
  6. 2,3,4,5を繰り返す

### F. ゲームオーバーの条件
9. 一番上のマスのどれかに宝石が設置されたらゲームオーバー

- ゲームオーバーかどうかの判定
  - ボード内の一番上の列の宝石のいずれかにGraphicsオブジェクトが配置されている(nullではない)かを判定

- ゲームオーバーまでの流れ
  1. 操作中のブロックを配置し、削除するべき宝石をすべて削除する
  2. ゲームオーバーかどうかを判定し、そうならアラートを出す
  3. すべてのパラメータを初期化する(スコア、レベル、操作中のブロック、ボード内の宝石、..)

### G. ブロックの自動落下
10. 一定時間ごとにブロックを下に落とす

- 1秒ごとに操作中のブロックを下に移動する関数を実行

### H. スコアの算出手順
11. 宝石が消えた時にスコアを増やす
12. スコアは消えた宝石の数に依存する。

- スコアの算出
  1. 今まで削除した宝石の数を取得
  2. 削除手順のの実行中にブロックのスコア、更新スコア、レベル、宝石を算出
  3. 算出した値の描画: pixi.jsのTextオブジェクトを用意して、以下のテキストを更新
    - スコア: 今までのスコア
    - 更新スコア: 直近の操作ブロックによって更新されたスコア全体
    - レベル: 現在のレベル、落下速度が変わる
    - 宝石: 消した宝石の数

- 次に操作する予定のブロックの描画
  1. 操作するブロックを決定するときに、次のブロックのオブジェクトも作成
  2. このオブジェクトを待機画面に表示
  3. 現在操作中のブロックの操作が完了した後、待機中の次のブロックを操作するブロックとして置き換える
  4. 1,2,3を繰り返す

### I. 連鎖によるスコアのボーナス
13. 宝石が連鎖で消えた時は、スコアがより増える

- 省略

### J. レベル機能
14. レベルはスコアに依存する(一定スコアごとにレベルアップ)
15. レベルが上がると宝石が落ちるスピードが上がる

- スコアは消した宝石の数を定数で割って切り上げたもの
- 落下速度はレベルを定数で割って切り上げたもの(上限あり)
